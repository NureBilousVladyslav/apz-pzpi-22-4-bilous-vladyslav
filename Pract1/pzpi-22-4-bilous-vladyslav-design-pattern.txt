Харківський університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії


Звіт 
 до практичного заняття з дисципліни 
«Архітектура програмного забезпечення» 
на тему «Патерни проєктування»
(завдання №1)





                                          Виконав ст. гр. ПЗПІ-22-4 
                                          Білоус Владислав Вячеславович
                                          
                                          Перевірив
                                          ст. викл. каф. ПІ 
                                          Сокорчук Ігор Петрович






Харків 2025


1 ІСТОРІЯ ЗМІН

№
Дата
Версія звіту
Опис змін та виправлень
1
20.03.2025
0.1
Створено розділи «Завдання», «Опис зміни»
2
21.03.2025
0.2
Створено розділ «Висновки» та додатки 
«Додаток А», «Додаток Б», «Додаток В»


2 ЗАВДАННЯ
     
     Вивчити патерн проєктування Adapter, з’ясувати його роль у розробці програмного забезпечення та ключові принципи роботи, дослідити приклади коду на мові java. Розглянути приклади використання патерну Adapter для забезпечення взаємодії між різними системами або компонентами.


3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Аналіз патерну Adapter
    
    Основна ідея патерна полягає в узгодженні інтерфейсів двох несумісних класів, що дозволяє забезпечити їх взаємодію без внесення змін до існуючого коду. Це особливо корисно при інтеграції сторонніх бібліотек або міграції на нову архітектуру.
    Патерн Adapter реалізується за допомогою двох основних підходів:
    * Об’єктний адаптер (з використанням композиції)
    * Класовий адаптер (з використанням наслідування)
    Основні принципи роботи:
    * Перетворення одного інтерфейсу на інший, очікуваний клієнтським кодом.
    * Забезпечення сумісності без зміни існуючих класів.
    * Приховування деталей реалізації адаптованого класу.
    
3.2 Аналіз прикладів коду на мові Java
    
    Для детального розуміння принципів роботи патерна були досліджені приклади реалізації Adapter на мові Java.
    Приклади коду до кожного з прикладів наведено у додатку В.

3.2.1 Об’єктний адаптер

    Об’єктний адаптер використовує композицію для зв’язку між класами. У цьому підході адаптер містить екземпляр адаптованого класу та делегує йому виклики методів. Це забезпечує більшу гнучкість у порівнянні з адаптером класу, оскільки дозволяє використовувати композицію замість наслідування.
    У прикладі є інтерфейс MediaPlayer, який визначає метод play(), що приймає тип аудіофайлу та його ім’я. Адаптований клас AdvancedMediaPlayer містить метод playMp4(), що обробляє відтворення MP4-файлів.
    Клас MediaAdapter реалізує MediaPlayer і містить екземпляр AdvancedMediaPlayer. Якщо переданий формат – MP4, адаптер викликає відповідний метод адаптованого класу. Завдяки цьому MediaAdapter дозволяє використовувати AdvancedMediaPlayer як частину MediaPlayer, що забезпечує сумісність між інтерфейсами.

    3.2.2 Адаптер класу
     
    Адаптер класу використовує наслідування замість композиції. У цьому підході адаптер одночасно наслідує як інтерфейс MediaPlayer, так і клас AdvancedMediaPlayer. Це дозволяє адаптеру безпосередньо викликати методи адаптованого класу без необхідності створення його екземпляра.
    Як і у попередньому випадку, інтерфейс MediaPlayer визначає метод play(), а AdvancedMediaPlayer містить метод playMp4(). Клас MediaAdapter успадковує AdvancedMediaPlayer і реалізує MediaPlayer. Це означає, що адаптер може викликати playMp4() безпосередньо, що робить реалізацію менш громіздкою.
    Однак цей підхід має свої обмеження. Оскільки Java не підтримує множинне наслідування, клас MediaAdapter може успадковувати лише один клас, що ускладнює його використання у випадках, коли необхідно адаптувати кілька різних класів.


4 ВИСНОВКИ
    Патерн «Адаптер» є потужним інструментом для забезпечення сумісності між класами з несумісними інтерфейсами, що дозволяє інтегрувати сторонні бібліотеки або працювати із застарілим кодом без його модифікації. Його застосування сприяє зменшенню залежностей та підвищенню гнучкості програмної архітектури.
    Існує два основні підходи до реалізації патерну: об’єктний та класовий адаптери. Об’єктний адаптер використовує композицію, що забезпечує гнучкість і розширюваність, дозволяючи працювати з різними реалізаціями адаптованого класу. Класовий адаптер застосовує наслідування, що спрощує реалізацію, але обмежує можливість використання адаптера лише одним базовим класом.
    Залежно від вимог конкретного проєкту, вибір між цими двома підходами впливає на масштабованість та підтримуваність коду. Об’єктний адаптер краще підходить для динамічних систем, де необхідна взаємодія з кількома різними класами, тоді як класовий адаптер ефективний у випадках, коли адаптований клас відомий наперед.

Додаток А
Відеозапис доповіді на YouTube: https://youtu.be/BE5o3H2EbDk
00:00 - Вступ;  
00:12 - Аналіз патерну;  
00:58 - Об'єктний адаптер. Вступ;  
01:30 - Об'єктний адаптер. Переваги та недоліки;  
02:25 - Об'єктний адаптер. Приклад;  
04:01 - Класовий адаптер. Вступ;  
04:40 - Класовий адаптер. Переваги та недоліки;  
05:35 - Класовий адаптер. Приклад;  
07:14 - Висновки;  
09:22 - Використані джерела;  

Додаток Б 
(слайди презентації доповіді)

Рисунок Б.1 – Титульна сторінка презентації


Рисунок Б.2 – Аналіз патерну Adapter


Рисунок Б.3 – Опис об’єктного адаптеру


Рисунок Б.4 – Переваги та недоліки об’єктного адаптеру

Рисунок Б.5 – Приклад об’єктного адаптеру


Рисунок Б.6 – Опис класового адаптеру


Рисунок Б.7 – Переваги та недоліки класового адаптеру


Рисунок Б.8 – Приклад класового адаптеру


Рисунок Б.9 – Висновки


Рисунок Б.10 – Використані джерела



Додаток В 
(приклади програмного коду)
В.1 Об’єктний адаптер
1   interface MediaPlayer {  
2     void play(String audioType, String fileName);  
3   }  
4   
5   class AdvancedMediaPlayer {  
6     void playMp4(String fileName) {  
7       System.out.println("Playing mp4 file: " + fileName);  
8     }  
9   }  
10   
11  class MediaAdapter implements MediaPlayer {  
12    private AdvancedMediaPlayer advancedMediaPlayer;  
13   
14    public MediaAdapter() {  
15      this.advancedMediaPlayer = new AdvancedMediaPlayer();  
16    }  
17   
18    @Override  
19    public void play(String audioType, String fileName) {  
20      if ("mp4".equalsIgnoreCase(audioType)) {  
21        advancedMediaPlayer.playMp4(fileName);  
22      }  
23    }  
24  }  

В.2 Класовий адаптер
1   interface MediaPlayer {  
2     void play(String audioType, String fileName);  
3   }  
4   
5   class AdvancedMediaPlayer {  
6     void playMp4(String fileName) {  
7       System.out.println("Playing mp4 file: " + fileName);  
8     }  
9   }  
10   
11  class MediaAdapter extends AdvancedMediaPlayer implements MediaPlayer {  
12    @Override  
13    public void play(String audioType, String fileName) {  
14      if ("mp4".equalsIgnoreCase(audioType)) {  
15        playMp4(fileName);  
16      }  
17    }  
18  }  
2


